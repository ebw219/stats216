{
  "_args": [
    [
      {
        "raw": "authen@~0.0.2",
        "scope": null,
        "escapedName": "authen",
        "name": "authen",
        "rawSpec": "~0.0.2",
        "spec": ">=0.0.2 <0.1.0",
        "type": "range"
      },
      "/Users/Kelli/Documents/Documents_Kellis MacBook Pro/cse216/cse216_lyle/web/node_modules/apis"
    ]
  ],
  "_from": "authen@>=0.0.2 <0.1.0",
  "_id": "authen@0.0.2",
  "_inCache": true,
  "_location": "/authen",
  "_npmUser": {
    "name": "dimsmol",
    "email": "dimsmol@gmail.com"
  },
  "_npmVersion": "1.3.2",
  "_phantomChildren": {},
  "_requested": {
    "raw": "authen@~0.0.2",
    "scope": null,
    "escapedName": "authen",
    "name": "authen",
    "rawSpec": "~0.0.2",
    "spec": ">=0.0.2 <0.1.0",
    "type": "range"
  },
  "_requiredBy": [
    "/apis"
  ],
  "_resolved": "https://registry.npmjs.org/authen/-/authen-0.0.2.tgz",
  "_shasum": "80574ff54d56bdd56e80e206965bd1ff6406390b",
  "_shrinkwrap": null,
  "_spec": "authen@~0.0.2",
  "_where": "/Users/Kelli/Documents/Documents_Kellis MacBook Pro/cse216/cse216_lyle/web/node_modules/apis",
  "author": {
    "name": "Dmitry Smolin",
    "email": "dimsmol@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/dimsmol/authen/issues"
  },
  "dependencies": {
    "async": "~0.1.17",
    "cookie": "~0.0.4",
    "marked_types": "~0.0.1",
    "ncbt": "~0.0.1",
    "ops": "~0.0.1"
  },
  "description": "Authentication tools - signing, tokens, password hashes",
  "devDependencies": {},
  "directories": {
    "lib": "./lib"
  },
  "dist": {
    "shasum": "80574ff54d56bdd56e80e206965bd1ff6406390b",
    "tarball": "https://registry.npmjs.org/authen/-/authen-0.0.2.tgz"
  },
  "engines": {
    "node": ">=0.8.0"
  },
  "homepage": "https://github.com/dimsmol/authen#readme",
  "keywords": [
    "authentification",
    "sign",
    "token",
    "password hash",
    "urlsafe base64"
  ],
  "main": "./lib/index",
  "maintainers": [
    {
      "name": "dimsmol",
      "email": "dimsmol@gmail.com"
    }
  ],
  "name": "authen",
  "optionalDependencies": {},
  "preferGlobal": false,
  "private": false,
  "readme": "# authen\n\nFeatures:\n\n* Passwords hashing for storing them on server-side and validation against the hashes\n* Signing data with secret\n* Encrypting and decrypting data with secret\n* Creation of simple tokens - signed or both encrypted and signed\n* Creation of auth tokens, validating them, handle renewal, expiration and revocation\n\nIf you are planning to use encryption, see \"Notes on Encryption\" to avoid possible pitfalls.\n\nAdditional tools:\n\n* Constant time equals for timing attacks prevention (tools/crypto)\n* Url-safe base64 encoder/decoder (tools/url_safe_base64)\n\n## Pwd\n\nPassword hashing tool.\n\n* hash(pwd, cb)\n* verify(pwd, hash, cb)\n\n## Signer\n\nSigns data using specified secret provided by dictionary of secrets.\n\nOptions:\n\n* algo - optional, default algorythm to use, 'sha1' will be used if not specified\n* allowedAlgos - optional, list of allowed algos (in addition to algo)\n* secrets - dict of secrets that can be used by signer\n* currentKey - default key to get secret for signing\n\nMethods:\n\n* calcSignature(data, opt_algo, opt_key) - calculates signature for data, using given algorythm and secret specified by given key\n\t* arguments\n\t\t* data can be string or Buffer\n\t\t* algo from options will be used if opt_algo is missed\n\t\t* currentKey from options will be used if opt_key is missed\n\t* returns a dict with the following fields:\n\t\t* signature - signature, as returned by calcSignatureRaw\n\t\t* algoName - actually used algoName (guaranted to to the same as opt_algoName, if specified)\n\t\t* key - actually used key (guaranted to to the same as opt_key, if specified)\n* calcSignatureRaw(data, algoName, secret) - internally used by calcSignature\n\t* returns null if data or secret is empty or algorythm is not allowed\n\t* otherwise returns signature (a Buffer object)\n* isValidSignature(signature, data, algoName, key) - returns true if signature is valid for given parameters\n\t* signature can be base64 string or Buffer\n* isValidSignatureRaw(signature, data, algoName, secret) - internally used by isValidSignature\n\n## Crypter\n\nEncrypts and decrypts data using specified secret provided by dictionary of secrets.\n\nOptions:\n\n* algo - optional, default algorythm to use, 'aes256' if not specified\n* allowedAlgos - optional, list of allowed algos (in addition to algo)\n* signingAlgos - optional, list of algos that includes signing in addition to encryption, dangerous, use only if you know what you're doing\n* secrets - dict of secrets that can be used by signer\n* currentKey - default key to get secret for signing\n\nMethods:\n\n* encrypt(data, opt_algo, opt_key) - encrypts data, using given algorythm and secret specified by given key\n\t* arguments\n\t\t* data can be utf8 string or Buffer\n\t\t* algo from options will be used if opt_algo is missed\n\t\t* currentKey from options will be used if opt_key is missed\n\t* returns a dict with the following fields:\n\t\t* data - encrypted data, as returned by encryptRaw\n\t\t* algoName - actually used algoName (guaranted to to the same as opt_algoName, if specified)\n\t\t* key - actually used key (guaranted to to the same as opt_key, if specified)\n* encryptRaw(data, algoName, secret) - internally used by encrypt()\n\t* returns null if data or secret is empty or algorythm is not allowed\n\t* otherwise returns encrypted data (a Buffer object)\n* decrypt(data, algoName, key) - decrypts data\n\t* data can be base64 string or Buffer\n* decryptRaw(data, algoName, secret) - internally used by decrypt()\n\n## AuthProvider\n\nProvides login and authentication features.\n\nOptions:\n\n* maxAge - max token age in ms, 2 weeks by default\n* useLimitedToken - use limited token for CSRF protection (see \"CSRF protection\" below), true by default\n* renewalInterval - how often renew token, 1 week by default\n* allowedIssuedClockDeviation - ms, how far in future can be issue date of token to still treat it as valid (useful to deal with small server clocks deviations), 5 min by default\n\nInitialization methods and properties:\n\n* type - string, can be used to identify provider if multiple are used\n* setTokener(tokener) - sets token creator, usually AuthTokener instance, see below\n\t* don't use Tokener instance instead of AuthTokener, it lacks number of methods required by AuthProvider\n* setAdapter(adapter) - sets auth data extractor and applier, usually HttpAdapter instance, see below\n* setRevoker(revoker) - sets optional object providing tokens revocation info, usually Revoker subclass instance, see below\n\nInitialization example:\n\n```js\nvar tokener = new AuthTokener();\ntokener.setSigner(new Signer({\n\tsecrets: { a: 'my secret' },\n\tcurrentKey: 'a'\n}));\n\nvar provider = new AuthProvider();\nprovider.setTokener(tokener);\nprovider.setAdapter(new HttpAdapter());\n```\n\nMethods:\n\n* login(res, identity, options, cb) - creates auth tokens for given identity, applies auth to res if res is not null\n\t* options available:\n\t\t* useCookies - set auth cookies if res is not null\n\t\t* isSessionLifetime - make cookies session lifetime\n\t* returns dict with:\n\t\t* tokenInfo\n\t\t\t* token\n\t\t\t* limitedToken\n\t\t\t* issued - token timestamp\n\t\t* identityStr - string representation of identity\n\t\t* result - result ready to return to client\n\t\t\t* token\n\t\t\t* issued\n\t\t\t* maxAge\n\t\t\t* isLimited - true if token is limited, see \"CSRF protection\" below\n\t\t\t* Note that identity and identityStr are not included to result, because it isn't always useful. If you need one of them or both, please include them yourself.\n* auth(req, res, options, cb) - extracts authentication data from request, creates renewal if need and applies it to res if it is not null\n\t* options available:\n\t\t* allowUnprotected - allows success even if not CSRF protected (useful for static files)\n\t\t* renewalMode - sets renewal mode:\n\t\t\t* null - auto, renew if it's time for it\n\t\t\t* 'skip' - do not renew\n\t\t\t* 'force' - renew\n\t* returns dict with:\n\t\t* type - provider type as initialized\n\t\t* identity - resolved identity\n\t\t* authResult - dict with lowlevel data:\n\t\t\t* authData - auth data extracted from req\n\t\t\t* tokenData - data extracted from token\n\t\t\t* renewalTokenInfo - token info used for renewal, structure is same as tokenInfo field returned by login()\n\t\t\t* renewal - renewal result ready to send to client, structure is same as result field returned by login()\n\t* can return AuthProblem object as an error, it's a [marked type](https://github.com/dimsmol/marked_types) and it's data field usually contains partially filled authResult structure of normal result, it's code field indicates type of problem:\n\t\t* NoAuthData - no auth data found\n\t\t* CSRF - CSRF protection required, but not found\n\t\t* InvalidToken - couldn't understand token\n\t\t* InvalidIssued - token's issued field is invalid (for example, too far in future)\n\t\t* Expired - token is expired\n\t\t* UnexpectedIdentity - token represents other identity than is expected, see \"Expected Identity\" below\n\t\t* Revoked - token is revoked\n* authByData(authData, res, options, cb) - same as auth(), but requires extracted authData instead of req, used by auth()\n* renew(res, tokenData, cb) - creates renewal and applies it to res if it is not null, used by authByData()\n* needRenew(tokenData) - checks if token needs renewal, used by authByData()\n* clearCookies(res) - clears auth cookies\n\nNote, that req and res arguments accepted by any of AuthProvider's methods will be just passed to adapter and won't used by AuthProvider itself. So, you use non-standard req or res objects with your own adapter instead of HttpAdapter with no need to change anything in AuthProvider.\n\n## Tokener\n\nCreates and parses tokens. Too simple for most cases, but can be used as a base for your tokeners.\n\nToken is a string guaranteed to contain only:\n\n* base64 characters\n* ':' character\n* characters of key and algo used by signer and/or crypter\n* your data characters (if not encrypted)\n\nNote, that characters from your data may be left \"as is\", so you possibly will want to perform escaping or something.\n\nMethods:\n\n* setSigner(signer) - sets signer, usually Signer instance\n* setCrypter(crypter) - sets crypter, usually Crypter instance\n* setAlgoMaps(maps) - sets optional mapping for algorythm names substitution, allows to hide real argorythm names or substitute they with shorter codes within token\n\t* maps is a dict with two optional properties:\n\t\t* signer - map for signer algorythm names\n\t\t* crypter - map for crypter algorythm names\n\t\t\t* map is a dict where key is algorythm name as used by crypter or signer and value is a string to be used within created token instead of real algorythm name\n\t\t\t* Note, that if map is present, but no mapping is found for particular algorythm, exception will be thrown (you can change this by overriding getMissedAlgoMapping() method)\n* createToken(data, opt_prefix) - creates token\n\t* expects data to be a string\n\t* token will be prepended with opt_prefix, that can be later obtained with Token.getPrefix()\n* parseToken(token) - parses token\n\t* returns null if token cannot be parsed or signature is invalid\n\t* otherwise returns a dict:\n\t\t* data - token data as previously passed to createToken()\n\t\t* issued - when token was created, timestamp\n* isValidIssued(issued, opt_allowedIssuedClockDeviation) - checks if issued is valid\n\t* is timestamp and is not too far in future (not further than on opt_allowedIssuedClockDeviation ms)\n* isExpired(issued, maxAge) - checks if issued is expired\n\t* maxAge is in ms\n\nBoth createToken() and parseToken() will return null if token is not at least signed. It can happen, for example, if both signer and crypter are null. See also \"Notes on Encryption\" below.\n\nStatic methods:\n\n* getPrefix(token, opt_separator) - extracts token prefix\n\t* opt_separator can be used for child classes overriding Tokener.prototype.separator\n\n## AuthTokener\n\nCreates and parses auth tokens. Is subclass of Tokener.\n\nNumber of Tokener methods made asynchronous to allow session-based token classes keeping the same interface.\n\nConstructor:\n\n* Tokener(opt_options)\n\t* options available:\n\t\t* prefix - prefix to be used for token, useful for separating different kinds of tokens, token versioning or whatever, empty string by default\n\nMethods:\n\n* createToken(identityStr, options, cb) - creates a token for identityStr\n\t* options:\n\t\t* isRenewal - must be true if token was created as a renewal\n\t\t* useCookies - must be true if initial login was performed with use of cookies (need to know for renewals)\n\t\t* isSessionLifetime - must be true if initial login was session lifetime (need to know for renewals)\n\t\t* useLimitedToken - must be true to use limited token for CSRF protection\n\t* returns a dict:\n\t\t* token\n\t\t* limitedToken\n\t\t* issued - timestamp\n* renewToken(tokenData, useLimitedToken, cb) - creates renewal token by given token data\n\t* tokenData must contain:\n\t\t* identityStr\n\t\t* useLimitedToken\n\t\t* useCookies\n\t\t* isSessionLifetime\n\t* returns the same as createToken()\n* parseToken(token, additionalToken, cb) - extracts token data checking signature and handling additional token\n\t* returns a dict:\n\t\t* identityStr\n\t\t* issued\n\t\t* isRenewal\n\t\t* useCookies\n\t\t* isSessionLifetime\n\n## HttpAdapter\n\nExtracts auth data from HTTP request and applies them to response.\n\nOptions:\n\n* cookie\n\t* httpOnly - use http only cookie, true by default\n\t* secure - use secure cookies, false by default\n\t* domain - domain for cookies, null (not specified) by default\n\t* path - path for cookies, '/' by default\n* names\n\t* cookie\n\t\t* auth - auth cookie name, 'auth' by default\n\t\t* authLimited - limited auth cookie name, 'authTwin' by default\n\t* header\n\t\t* auth - auth header name (request), 'X-Auth' by default\n\t\t* expected - expected identity header name (request), 'X-AuthExpected' by default\n\t\t* renewal - renewal token headername (response), 'X-AuthRenewal' by default\n\t\t* renewalIssued - renewal issued timestamp header name (response), 'X-AuthRenewalIssued' by default\n\t\t* renewalMaxAge - renewal max age header name (response), 'X-AuthRenewalMaxAge' by default\n\nMethods:\n\n* extractAuthData(req) - extracts auth data from request\n\t* returns a dict:\n\t\t* token\n\t\t* additionalToken\n\t\t* isCsrfProtected - true if request is CSRF protected\n\t\t* expectedIdentityStr\n* applyAuthData(res, tokenInfo, maxAge, useCookies) - applies auth data to response\n\t* tokenInfo is a dict:\n\t\t* token\n\t\t* limitedToken\n\t\t* issued\n\t* maxAge is used for cookies only\n* applyRenewal(res, renewalTokenInfo, maxAge, useCookies) - the same as applyAuthData(), but for renewals\n* clearCookies(res) - clears auth cookies\n\n## Revoker\n\nProvides info about token revocation. This is an abstract class representing \"last revocation time\" based revocation - all tokens issued before given time moment are treated as revoked. You must override getLastRevokationTime() method to get working implementation.\n\nOptions:\n\n* postRevocationTrustDelay - specifies a period after revocation in ms for which all renewal tokens will be treated as revoked, 5 min by default. This allows to prevent keep previously got token active by continuously renewing it. Period must be long enough to allow all the servers share info about latest \"last revokation time\" update.\n\nMethods:\n\n* checkRevoked(tokenData, cb) - checks if given token is revoked\n\t* returns true if token is revoked\n* getLastRevokationTime(cb) - abstract method you must implement\n\t* returns last revokation time timestamp\n\n## CSRF protection\n\nCSRF is a problem closely related to cookies. So it's applied if you use cookies for authentication.\n\nAuth cookie itself is not enough to ensure request is initiated by user or by trusted web application. So, AuthProvider requires auth token to be added to request HTTP header as well to ensure request is CSRF protected.\n\n_Note, that it couldn't be done for static requests, so they cannot be CSRF protected._\n\nBut auth cookie is often \"http only\", so JS code have no access to auth token. To solve this problem, AuthProvider allows to generate pair of tokens - normal and limited one. This way normal token will be stored in auth cookie and limited one will be stored in other cookie and also returned to client. Client then can use limited cookie to add it to request header. Limited token is itself not enough for authentication and after getting it AuthProvider will try to get normal token from auth cookie. If both tokens match each other, normal token will be used for authentication.\n\nNote, that useLimitedToken option of AuthProvider is useful only for \"http only\" cookies, or else you can use normal auth token from cookie to copy it to HTTP header. And vice versa, if \"http only\" cookie is used, there is no sense to disable useLimitedToken, because this way result sent to client will contain normal token and JS will have access to it (which we tried to prevent using \"http only\" cookie).\n\nAnd again, all this stuff is useful only for authentication using cookies, sending auth token in HTTP header is CSRF protected without any additional tricks.\n\n## Expected Identity\n\nIf user authenticated in one browser tab reauthenticates in other, first one will send requests with new auth cookies without even knowing it. So it can end up with mixed data - some loaded with old authentication and some with new one.\n\nTo prevent such a mess, you can add expected identity known to your application to HTTP header (usuall X-AuthExpected). If expected identity is provided, AuthProvider will check that your auth token is expected one.\n\n## Notes on Encryption\n\n### Signing\n\nEncryption itself is not enough to protect your tokens. You must encrypt data then sign. Some encryption algorythms provide signing themselves, for all others you must use signing provided by authen.\n\nTokener ensures that data are at least signed (by Signer or by encryption algorythm). That's why you can get null from createToken() if signer is null even if crypter is not null.\n\nAlso, do not use the same secrets for encryption and for signing.\n\n### Data Padding\n\nSometimes your data length can be guessed by token length. And then your data can be guessed by data length. It is especially true if your data are short, which is true for most tokens.\n\nIf, for example, your data length is 1 byte, there are only 256 varinants what they are.\n\nProblem can still remain for relatively large data. For example, if data is stringifyed user id and you have 10005 users total, any data of size 5 indicates a user with id between 10000 and 10005 - only 6 possible variants.\n\nUsually, encryption algorythm will extaned your data to the nearest block size and it will make guessing harder. But to be completely sure your data cannot by guessed by length, it's recommended to pad them to some certain length before encryption. You can do it overriding Tokener's packData() and unpackData() methods.\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dimsmol/authen.git"
  },
  "version": "0.0.2"
}
