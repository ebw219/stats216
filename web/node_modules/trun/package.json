{
  "_args": [
    [
      {
        "raw": "trun@~0.0.1",
        "scope": null,
        "escapedName": "trun",
        "name": "trun",
        "rawSpec": "~0.0.1",
        "spec": ">=0.0.1 <0.1.0",
        "type": "range"
      },
      "/Users/Kelli/Documents/Documents_Kellis MacBook Pro/cse216/cse216_lyle/web/node_modules/apis"
    ]
  ],
  "_from": "trun@>=0.0.1 <0.1.0",
  "_id": "trun@0.0.1",
  "_inCache": true,
  "_location": "/trun",
  "_npmUser": {
    "name": "dimsmol",
    "email": "dimsmol@gmail.com"
  },
  "_npmVersion": "1.3.2",
  "_phantomChildren": {},
  "_requested": {
    "raw": "trun@~0.0.1",
    "scope": null,
    "escapedName": "trun",
    "name": "trun",
    "rawSpec": "~0.0.1",
    "spec": ">=0.0.1 <0.1.0",
    "type": "range"
  },
  "_requiredBy": [
    "/apis"
  ],
  "_resolved": "https://registry.npmjs.org/trun/-/trun-0.0.1.tgz",
  "_shasum": "3bb09e3887f05f66a8b4c4046bb086222f1acada",
  "_shrinkwrap": null,
  "_spec": "trun@~0.0.1",
  "_where": "/Users/Kelli/Documents/Documents_Kellis MacBook Pro/cse216/cse216_lyle/web/node_modules/apis",
  "author": {
    "name": "Dmitry Smolin",
    "email": "dimsmol@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/dimsmol/trun/issues"
  },
  "dependencies": {},
  "description": "task runner",
  "devDependencies": {},
  "directories": {
    "lib": "./lib"
  },
  "dist": {
    "shasum": "3bb09e3887f05f66a8b4c4046bb086222f1acada",
    "tarball": "https://registry.npmjs.org/trun/-/trun-0.0.1.tgz"
  },
  "engines": {
    "node": ">=0.8.0"
  },
  "homepage": "https://github.com/dimsmol/trun#readme",
  "keywords": [
    "task",
    "run",
    "make",
    "makefile"
  ],
  "main": "./lib/index",
  "maintainers": [
    {
      "name": "dimsmol",
      "email": "dimsmol@gmail.com"
    }
  ],
  "name": "trun",
  "optionalDependencies": {},
  "preferGlobal": false,
  "private": false,
  "readme": "# trun\n\ntrun is simple task runner. In many cases it's better than `make` for node.js projects management.\ntrun tasks are described as js module, so they are fully js-powered.\n\ntrun provides number of entities which can help you to hide complex and ugly things and keep your tasks simple and elegant. But at any point you can use regular js function with any functionality.\n\ntrun has focus on simple running shell commands, because this is what you need often. It hides asynchronous nature of corresponding node.js functionality making running sets of shell commands very easy.\n\nAll trun syntax sugar providing classes are extandable, so you can easily create your own WrappedTask or Resolvable providing some sugar for your regular tasks.\n\nIt's recommended to:\n\n* store your tasks in file named `tasks.js`\n* add `alias run='node tasks.js'` to your shell profile\n\n## running the task\n\nAssuming you have `run` alias mentioned above.\nIf not, use `node tasks.js` instead of `run`.\n\n```sh\n# run default task\nrun\n\n# run task hello\nrun hello\n\n# run task sometask\nrun sometask\n\n# run task hello with arguments\nrun hello world \"a b c\" 123\n\n# run default task with arguments\nrun - arg1 arg2\n```\n\n## tasks.js example\n\nIt's located in `example` directory and all task running examples provided above will work with it.\nThe only difference is that it references trun library as '../lib'.\n\n```js\n\"use strict\";\nvar trun = require('trun');\nvar run = trun.wrapped.run;\nvar apply = trun.wrapped.apply;\nvar print = trun.wrapped.print;\nvar args = trun.resolvable.args;\n\nvar runner = new trun.Runner();\nrunner.addTasks({\n\tdefault:\n\t\t'dev',\n\n\tdev: [\n\t\tapply('hello', args),\n\t\t'compile',\n\t\t'run'\n\t],\n\n\thello:\n\t\tprint('hello ', args.cmdArgs),\n\n\tcompile:\n\t\tprint('compiling...'),\n\n\trun: function (cb) {\n\t\t// do something useful\n\t\tthis.runTasks([\n\t\t\t// using wrapped tasks within custom function\n\t\t\trun('echo ', args)\n\t\t], ['running'], cb);\n\t},\n\n\totherTask:\n\t\tprint('othertask says: ', args.get(0)),\n\n\tsometask: [\n\t\t'hello',\n\t\tfunction () {\n\t\t\tvar args = this.getArgs(arguments);\n\t\t\tvar cb = this.getCb(arguments);\n\t\t\tthis.print('sometask is called with arguments: ', this.toCmdArgs(args));\n\t\t\tthis.tasks.otherTask('hi there', cb);\n\t\t}\n\t]\n});\nrunner.start();\n```\n\nMore complex example can be found in `test/tasks.js`.\n\n## Main principles\n\n* every task has name - key in dictionary argument of `runner.addTasks()`\n* every task is an asynchronous function\n* every task's function last argument is a callback that must be called when task is completed\n\t* first argument of callback function is error, it must be null or undefined if no error occured\n\t* any count of other arguments are 'result'\n\t* if error passed to callback has non-null `exitCode` property and will cause termination, program will exit with given exit code\n\t* if error is instance of `trun.errors.Exit` and will cause termination, program will exit silently (without stacktrace or something)\n* if task function has no arguments in it's definition, it is treated as variable length arguments function\n\t* it can be called with any number of arguments\n\t* but last argument must be a callback\n* if task function has some arguments, it is treated as fixed length arguments function and it's last argument will always be used for callback\n\nalso\n\n* every task function, when called has `runner` instance provided as `this`\n\t* so, can use utilities and other methods of runner\n* you can call other tasks from your task function, tasks dictionary will be provided as `this.tasks` and all tasks will be already bound to `runner`\n* of course, you can also require any libs and run any code before, after or within your tasks definitions\n\nSo, typical task function may look like:\n\n```js\nfunction (a, b, c, cb) { // fixed length args\n\t// do something\n\tthis.print('hi )'); // using runner methods\n\tcb(null, 12); // result is 12\n}\n```\nor\n\n```js\nfunction () { // variable length args\n\tvar args = this.getArgs(arguments); // using util to get arguments except callback\n\tvar cb = this.getCb(arguments); // same for cb\n\tthis.print(args);\n\tcb(); // don't forget to call cb\n}\n```\n\nAnd other task call may look like\n\n```js\nthis.tasks.otherTask(arg1, arg2, cb);\n```\n\nor\n\n```js\nthis.tasks.otherTask.apply(null, [arg1, arg2, cb]);\n```\n\n## cb.ctx\n\nCallback function may have ctx object attached to it. If it is present, it may contain following properties:\n\n* prevResult - result array passed to callback by previously runned task\n* box - dictionary shared between all calls in context of one `arr` task wrapper\n\t* can be used to pass a value to some of next tasks\n\nctx is usually available in context of `arr` task wrapper, see below.\n\n## runner methods and properties\n\nAny task function's `this` references `runner` object, so all methods and properties below are available for it.\n\n* tasks - references tasks dictionary, you can find examples of running other tasks from it above\n* runTasks(tasks, args, cb) - wraps tasks into `arr` and runs obtained task function with given arguments\n\t* allows to use wrapped tasks within your custom task function\n* getArgs(arguments) - returns arguments without last one which is callback by agreement\n\t* useful for variable length arguments handling, see above\n* getCb(arguments) - returns last argument which is callback by agreement\n\t* also for variable length arguments handling, see above\n* run(arg1, ..., cb) - flattens and concatenates arguments then runs obtained string as a shell command\n\t* generates an error if command exit code is not 0\n* prun(arg1, ..., cb) - as run but prints command before executing it\n* tryRun(areg1, ..., cb) - like `run` but doesn't generate error if exit code is not 0, provides exit code as a result instead\n* tryPrun(arg1, ..., cb) - like tryRun, but prints command before executing it\n* toCmdArgs(args) - escapes given arguments to be suitable to form command line arguments\n* joinStr(parts) - flattens and joins parts into single string\n* print(arg1, ...) - flattens, concatenates and prints arguments\n* exit(cb, opt_code) - produces Exit error with give exit code\n\n## Sugar\n\nThere are two kinds of sugar entities:\n\n* WrappedTask - functions which generate task functions\n* Resolvable - objects that can describe some data to be used by WrappedTask functions which must be resolved at execution time\n\n### Conversion to WrappedTask\n\n* if task is Array, it will be converted to `arr`\n* if task is String, it will be converted to:\n\t* `alias` for top-level tasks\n\t* `call` for any other\n\n### WrappedTask functions\n\nWrappedTask functions are located in `trun.wrapped` module.\n\n* arr(task1, ...) - represents set of tasks that will be executed one by one\n\t* if any of tasks calls callback with error, following tasks will be skipped and arr's callback will be called with error immediately\n\t* `arr` attempts to pass to underlying tasks as many it's arguments as they are ready to receive\n* toBox(k, v) - will put value v to 'box' under key k, box exists in context of arr() set of tasks only\n\t* you can use `box` resolvable to access stored value\n\t* also you can use cb.ctx.box to access box from within your function\n* print(arg1, ...) - prints flattens, concatenates and prints arguments\n\t* understands resolvables at any level of depth\n* result(arg1, ...) - calls it's callback providing arguments as result\n\t* mainly for using in arr() context\n\t* result array can be accessed by `prev` resolvable\n\t* also result can be obtained using cb.ctx.prevResult from within your function\n* run(arg1, ...) - flattens and concatenates arguments then runs obtained string as a shell command\n\t* understands resolvables at any level of depth\n\t* generates an error if command exit code is not 0\n* prun(arg1, ...) - like `run` but prints command before executing it\n* tryRun(arg1, ...) - like `run` but doesn't generate error if exit code is not 0, provides exit code as a result instead\n\t* exit code can then be accessed via `prev` resolvable or cb.ctx.prevResult\n* tryPrun(arg1, ...) - like tryRun, but prints command before executing it\n* alias(name) - runs task with given name traversing arguments to it\n* call(name, arg1, ...) - runs task with given name providing given arguments to it\n\t* understands resolvables as any of arguments, but not their internal parts\n* apply(name, [arg1, ...]) - like `call`, but arguments must be specified as an array\n* exit(code) - produces Exit error\n\t* understands resolvables as code\n\n### Resolvable objects\n\nResolvable objects are located in `trun.resolvable` module.\n\n* args - represents arguments passed to this context\n* box - represents box shared between all task functions in `arr` context\n* custom(f(runner, ctx)) - returns result of calling given function which will have runner and ctx as arguments\n* prev - represents prevResult, result array of previously runned task in `arr` context\n\n`args` and `prev` have following methods and properties:\n\n* slice(start, end) - provides slice of value\n* get(pos) - provides single element\n* cmdArgs - applies `toCmdArgs()` on value (see above)\n\n`box` has following methods and properties:\n\n* get(k) - gets value with key `k` from box\n* cmdArgs - applies `toCmdArgs()` on value (see above)\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dimsmol/trun.git"
  },
  "version": "0.0.1"
}
